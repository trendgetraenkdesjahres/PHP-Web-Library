<?php

namespace System;

use Debug\Debug;
use Notices\Notice;
use Notices\Warning;


/**
 * ProgramHandleInterface defines the interface for creating and executing shell commands.
 */
interface ProgramHandleInterface
{
    public function add_option(string $flag, string $argument, string $name): ProgramHandle;
    public function set_source_files(string $file_pattern, string $input_flag): ProgramHandle;
    public function set_destination_file(string $file_name): ProgramHandle;
    public function execute(): ProgramHandle;
    public function get_execute(): string;
}


/**
 * ProgramHandle represents a class for creating and executing shell commands.
 */
class ProgramHandle implements ProgramHandleInterface
{
    protected array $sources;
    protected array $destiantion;
    protected array $options = [];

    public ?string $result_line = null;
    public ?array $full_output = null;
    public ?int $result_code = null;
    protected ?ProgramHandle $pipe_to = null;

    public function __construct(public ?string $command = null)
    {
    }

    /**
     * Set the source file(s) based on a glob pattern and an input flag.
     *
     * @param string $file_pattern The glob pattern for source files.
     * @param string $input_flag The input flag for the source files.
     * @return ProgramHandle The modified ProgramHandle instance.
     */
    public function set_source_files(string $file_pattern, string $source_flag = 'i'): ProgramHandle
    {
        $files = glob($file_pattern);
        if (is_array($files)) {
            if (count($files) > 0) {
                $cleaned_files = array_map(function ($file) {
                    return realpath($file);
                }, $files);
                $this->add_option(
                    name: "sources",
                    flag: $source_flag,
                    argument: $cleaned_files
                );
                $this->sources = $files;
            } else {
                Notice::trigger("No files in '$file_pattern'");
            }
        } else {
            Warning::trigger("Invalid glob-pattern: '$file_pattern'");
        }
        return $this;
    }

    /**
     * Set the source.
     *
     * @param string $source.
     * @param string $input_flag The input flag for the source.
     * @return ProgramHandle The modified ProgramHandle instance.
     */
    public function set_source(string $source, string $source_flag = ''): ProgramHandle
    {
        $this->add_option(
            name: "sources",
            flag: $source_flag,
            argument: $source
        );
        $this->sources[0] = $source;

        return $this;
    }

    /**
     * Set the destination file for the command.
     *
     * @param string $filename The destination filename.
     * @return ProgramHandle The modified ProgramHandle instance.
     */
    public function set_destination_file(string $filename, string $destination_flag = ''): ProgramHandle
    {
        $this->add_option(
            name: "destination",
            flag: $destination_flag,
            argument: $filename
        );
        return $this;
    }

    /**
     * Add an option to the command.
     *
     * @param string $flag The flag for the option.
     * @param string|array $argument The argument for the option.
     * @param string|null $name The name of the option.
     * @return ProgramHandle The modified ProgramHandle instance.
     */

    public function add_option(string $flag = '', string|array $argument = '', ?string $name = null): ProgramHandle
    {
        if (!$flag && !$argument) {
            return $this;
        }
        if ($flag) {
            if (strpos($flag, '-',) !== 0) {
                $flag = (strlen($flag) >= 2) ? "--$flag" : "-$flag";
            }
        }
        $option = '';

        if (is_array($argument)) {
            foreach ($argument as $value) {
                $option .= "$flag \"$value\" ";
            }
        } elseif (is_string($argument)) {
            $option = "$flag \"$argument\"";
        }

        if ($name) {
            $this->options[$name] = trim("$option");
        } else {
            array_push($this->options, $option);
        }

        return $this;
    }

    /**
     * Add an option with a dynamic value generated by a callback function.
     *
     * @param string $flag The flag for the option.
     * @param callable $value_callback The callback function to generate the option value.
     *                                The function should accept the current ProgramHandle instance and return a string.
     */
    public function add_dynamic_option(string $flag = '', callable $callback): ProgramHandle
    {
        $reflection = new \ReflectionFunction($callback);
        if ($reflection->getReturnType() != 'string') {
            throw new \Error("Callback function does not return a string.");
        }

        if (
            count($reflection->getParameters()) != 1
            || $reflection->getParameters()[0]->getType() != get_class($this)
        ) {
            throw new \Error("Callback function should have only one parameter of type 'ProgramHandle', but it is '" . $reflection->getParameters()[0]->getType() . "'.");
        }

        $option = call_user_func($callback, $this);
        $this->add_option($flag, $option);
        return $this;
    }

    /**
     * Get the complete command string to execute.
     *
     * @return string The command string.
     */
    public function get_execute_string(): string
    {
        if ($this->pipe_to) {
            $this->pipe_to->get_execute_string();
        }

        if (isset($this->options['sources'])) {
            $sources_option = $this->options['sources'];
            unset($this->options['sources']);
            $this->options['sources'] = $sources_option;
        }
        if (isset($this->options['destination'])) {
            $destination_option = $this->options['destination'];
            unset($this->options['destination']);
            $this->options['destination'] = $destination_option;
        }

        return implode(
            " ",
            [
                $this->command,
                implode(" ",                $this->options)
            ]
        );
    }

    /**
     * Execute the command and capture the result.
     *
     * @return ProgramHandle The modified ProgramHandle instance.
     */
    public function execute(): ProgramHandle
    {
        $this->result_line = exec(
            command: $this->get_execute_string(),
            output: $this->full_output,
            result_code: $this->result_code
        );
        return $this;
    }

    public function pipe(): ProgramHandle
    {
        $pipe = new ProgramHandle(); // Create a new instance of ProgramHandle for the next command in the pipeline.
        $this->pipe_to = $pipe;
        return $pipe;
    }

    /**
     * Get array of registred source / input files
     *
     * @return string The command string.
     */
    public function get_source_files(): array
    {
        return $this->sources;
    }

    /**
     * Get the result of the executed command.
     *
     * @return string The result of the executed command.
     */
    public function get_execute(): string
    {
        if (!$this->result_line) {
            $this->execute();
        }
        return $this->result_line;
    }
}
